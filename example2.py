#!/usr/bin/env python3
"""
Example of a pipeline with two gRPC services
"""

import logging
import json
import sys
import os
import base64

# Add the src directory to the Python path if needed
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), 'src')))

# Import the necessary components from apifunc
from apifunc.apifunc import ApiFuncConfig, ApiFuncFramework
from apifunc.components import DynamicgRPCComponent

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Define the pipeline components as functions
def json_to_html(json_data):
    """Convert JSON data to HTML"""
    try:
        # Parse JSON if it's a string
        if isinstance(json_data, str):
            data = json.loads(json_data)
        else:
            data = json_data

        # Create a simple HTML representation
        html = f"""
        <html>
        <head>
            <title>{data.get('title', 'Report')}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                h1 {{ color: #2c3e50; }}
                .info {{ color: #7f8c8d; margin-bottom: 20px; }}
                .content {{ line-height: 1.6; }}
            </style>
        </head>
        <body>
            <h1>{data.get('title', 'Report')}</h1>
            <div class="info">
                <p>Author: {data.get('author', 'Unknown')}</p>
                <p>Date: {data.get('date', 'N/A')}</p>
            </div>
            <div class="content">
                <p>{data.get('content', '')}</p>
            </div>
        </body>
        </html>
        """

        return html
    except Exception as e:
        logger.error(f"Error converting JSON to HTML: {e}")
        return f"<html><body><h1>Error</h1><p>{str(e)}</p></body></html>"

def html_to_pdf(html_content):
    """Convert HTML to PDF using WeasyPrint"""
    try:
        # Import WeasyPrint here to avoid dependency issues
        from weasyprint import HTML
        import io

        # Convert HTML to PDF
        pdf_buffer = io.BytesIO()
        HTML(string=html_content).write_pdf(pdf_buffer)

        # Return PDF as base64 encoded string for gRPC transport
        pdf_data = pdf_buffer.getvalue()
        return base64.b64encode(pdf_data).decode('utf-8')
    except Exception as e:
        logger.error(f"Error converting HTML to PDF: {e}")
        raise

# Pipeline orchestrator class
class PipelineOrchestrator:
    """Class to orchestrate the execution of pipeline components"""

    def __init__(self):
        self.components = []

    def add_component(self, component):
        """Add a component to the pipeline"""
        self.components.append(component)

    def execute_pipeline(self, input_data):
        """Execute the pipeline with the given input data"""
        current_data = input_data

        for i, component in enumerate(self.components):
            logger.info(f"Executing component {i+1}/{len(self.components)}: {component.name}")
            current_data = component.process(current_data)

        return current_data

def main():
    try:
        logger.info("Starting the apifunc example pipeline with two services...")

        # Sample data
        sample_data = {
            "title": "Sample Report",
            "author": "APIFunc",
            "date": "2025-03-28",
            "content": "This is a sample report generated by APIFunc."
        }

        # Create configurations for both services
        json_html_config = ApiFuncConfig(
            proto_dir="./proto/json_html",
            generated_dir="./generated/json_html",
            port=50051
        )

        html_pdf_config = ApiFuncConfig(
            proto_dir="./proto/html_pdf",
            generated_dir="./generated/html_pdf",
            port=50052
        )

        # Create framework instances
        json_html_framework = ApiFuncFramework(json_html_config)
        html_pdf_framework = ApiFuncFramework(html_pdf_config)

        # Register functions with frameworks
        json_html_framework.register_function(json_to_html)
        html_pdf_framework.register_function(html_to_pdf)

        # Start servers in separate threads
        import threading

        def run_server(framework, name):
            logger.info(f"Starting {name} server on port {framework.config.port}")
            server = framework.start_server()
            try:
                server.wait_for_termination()
            except KeyboardInterrupt:
                server.stop(0)
                logger.info(f"{name} server stopped")

        # Start servers in background threads
        json_html_thread = threading.Thread(
            target=run_server,
            args=(json_html_framework, "JSON-to-HTML"),
            daemon=True
        )

        html_pdf_thread = threading.Thread(
            target=run_server,
            args=(html_pdf_framework, "HTML-to-PDF"),
            daemon=True
        )

        json_html_thread.start()
        html_pdf_thread.start()

        # Give servers time to start
        import time
        time.sleep(2)

        # Create gRPC clients for the services
        import grpc

        # Create components that use the gRPC services
        json_html_component = DynamicgRPCComponent(
            json_to_html,
            proto_dir=json_html_config.proto_dir,
            generated_dir=json_html_config.generated_dir
        )

        html_pdf_component = DynamicgRPCComponent(
            html_to_pdf,
            proto_dir=html_pdf_config.proto_dir,
            generated_dir=html_pdf_config.generated_dir
        )

        # Create and execute pipeline
        pipeline = PipelineOrchestrator()
        pipeline.add_component(json_html_component)
        pipeline.add_component(html_pdf_component)

        # Execute pipeline
        logger.info("Executing pipeline...")
        result = pipeline.execute_pipeline(sample_data)

        # Decode the base64 PDF data
        pdf_data = base64.b64decode(result)

        # Save the result
        output_file = "output.pdf"
        with open(output_file, "wb") as f:
            f.write(pdf_data)

        logger.info(f"Pipeline executed successfully. Output saved to {output_file}")

    except Exception as e:
        logger.error(f"Error processing: {e}")
        import traceback
        traceback.print_exc()

    # Keep the main thread running to allow the server threads to continue
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Shutting down...")

if __name__ == "__main__":
    main()
